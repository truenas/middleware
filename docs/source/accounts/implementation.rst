Implementation notes                                                                                                                      ====================

.. contents:: Table of Contents
    :depth: 3


Identity providers
==================
Users and groups on the TrueNAS servers are provided by Name Service Switch (NSS) modules configured on the TrueNAS
server. Local accounts are provided by the standard "files" NSS module provided by glibc. Directory services accounts
are provided by winbindd when TrueNAS is joined to an Active Directory domain, or SSSD if TrueNAS is joined to a FreeIPA
domain or bound to an LDAP server. In the context of TrueNAS accounts, these modules provide the standard passwd(5) and
group(5) entries on the server as exposed in cpython by the pwd and grp modules, and in the TrueNAS middleware by
`utils/nss/pwd` and `utils/nss/grp`. The configured identity providers in TrueNAS control the implementation of
of authorization of authenticated middlewared sessions. Authentication itself is provided by Linux Pluggable
Authentication Modules (PAM). See `docs/source/middleware/session.rst` for details on authentication and session
management.


Configuration
-------------
Identity providers are initially configured through administrative interaction with the middlewared process through
the TrueNAS webui or API. Relevant state is stored in the freenas-v1.db sqlite3 database, but this file is not
consumed by identity providers. The configuration files and steps for identity providers are defined as below in
the context of headings associated by the relevant NSS modules. NSS modules are enabled by writing the
`/etc/nsswitch.conf` file, which is performed by the middlewared process when `etc.generate` `nss` is called.
NOTE: older versions of glibc would not allow applications to reload the nsswitch.conf file at runtime, which
is reflected in early versions of TrueNAS SCALE having a static `nsswitch.conf` file. The contents of the
`nsswitch.conf` file are changed as directory services are enabled and disabled.


nss_files
^^^^^^^^^
The files NSS module is provided by glibc and controls local user accounts through the standard passwd(5), group(5),
and shadow(5) files. These files are written by calling the `etc.generate` `user`, which happens during the boot
process or whenever an administrator uses the `user` and `group` CRUD APIs. The shadow file may be independently
regenerated by the middlewared process when a user resets its password.


nss_winbind
^^^^^^^^^^^
The winbind NSS module is provided by the samba suite (https://github.com/truenas/samba) and provides accounts
when joined to active directory. Note that the winbindd process (not the NSS module) provides SIDs for local
accounts provided by the files NSS module when TrueNAS does not have directory services configured. Hence,
it is expected the winbindd process will be present and running even if SMB or directory services are not
configured. The relevant configuration file is `/etc/smb4.conf`, but management of winbindd in the context of
its role as an identity provider must be through the `directoryservices` middlewared plugin and is non-trivial.


nss_sss
^^^^^^^
The SSS NSS module is provided by System Security Services Daemon (https://github.com/truenas/sssd) and provides
directory services accounts when TrueNAS is joined to a FreeIPA domain or bound to an LDAP server.
The relevant configuration file is `/etc/sssd/sssd.conf`, but management of sssd in the context of its role as
an identity provider must be throuh the `directoryservices` middlewared plugin and is non-trivial.


Caching
-------

The name service cache daemon (nscd(8)) is provided by glibc and has the capability to cache NSS responses
for accounts. This capability is *disabled* in TrueNAS and must remain disabled because it interacts poorly
with NSS modules that implement their own internal caching such as nss_winbind and nss_sss.

The nss_winbind and nss_sss modules implement internal caches for directory server responses in order to
avoid introducing network-related latencies to application requests for account information. This is critical
to the proper operation of the TrueNAS server under load.


Data structures
---------------
The following provides examples of struct passwd and struct group as returned by glibc NSS-related functions.


Struct passwd
^^^^^^^^^^^^^
The passwd structure is defined in <pwd.h> as follows::

    struct passwd {
        char   *pw_name;       /* username */
        char   *pw_passwd;     /* user password */
        uid_t   pw_uid;        /* user ID */
        gid_t   pw_gid;        /* group ID */
        char   *pw_gecos;      /* user information */
        char   *pw_dir;        /* home directory */
        char   *pw_shell;      /* shell program */
    };


Struct group
^^^^^^^^^^^^
The group structure is defined in <grp.h> as follows::

    struct group {
        char   *gr_name;        /* group name */
        char   *gr_passwd;      /* group password */
        gid_t   gr_gid;         /* group ID */
        char  **gr_mem;         /* NULL-terminated array of pointers
                                   to names of group members */
    };

NOTE: not all NSS modules will populate `gr_mem` in responses due to cost of retrieval.


Errata
------
A broken directory services configuration may introduce significant delays for almost all shell or API
interactions with the TrueNAS server to the point where it can become unusable. This can for example manifest
as hangs for up to 60 seconds when trying to stat(1) a file, ls(1) a directory, or perform various
administrative actions. A temporary remedy if access for local accounts is available is to manually edit
`/etc/nsswitch.conf` to remove the `sss` or `winbind` entries from the `group` and `passwd` lines of the
file. Note that developers need to exercise caution if they want to detect such issues and proactively
disable directory service because it is easy to be over-aggressive and take a server out of production when
it is only experiencing intermittent delays.


Middleware Accounts
===================

The middlewared API expands on the standard account information defined in the glibc data structures
in various ways. This section notes some of the APIs and how they expand the information. A possible future
enhancement is tighter intergration between our local accounts API and JSON User/Group records in systemd.
Note that any expansion beyond Unix / glibc NSS responses may not be visible in applications outside of
middlewared. Developers should exercise caution in expanding fields provided by the `user` and `group`
plugin because any changes will need to be handled for directory services accounts as well.

WARNING: the middleware APIs provide both an `id` value and a `uid` or `gid` value. These must not be conflated.
The `id` refers to the datastore primary key and has no relevance to the NSS response and is unknown outside of the
middleware process.


middleware.utils.nss
--------------------

Middlewared uses its own ctypes wrapper around the standard glibc functionality. This allows us to determine
the actual NSS module that resolves a particular account, which is important for middlewared to determine
the `source` of the account (e.g. whether it's local, from AD, LDAP, or IPA).


APIs
----

The following is a brief synopsis of major account-related APIs in middleware. Actual definitions should
be obtained through the explicit API documentation.


Account IDs verses UIDs and GIDs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A common developer mistake is to conflate that datastore primary key `id` with the NSS user id `uid` or
group id `gid`. In the case of local accounts, the datastore primary key `id` has no relationship at
all with the NSS `uid` or `gid`. For example in the following group entry::

  {
    "id": 114,
    "gid": 3004,
    "name": "test",
    "builtin": false,
    "sudo_commands": [],
    "sudo_commands_nopasswd": [],
    "smb": false,
    "group": "test",
    "local": true,
    "sid": null,
    "roles": [],
    "users": [
      74
    ]
  }

The `id` here is a datastore primary key, `gid` is the group id provided by NSS, `users` is an array
of datastore `id` values for datastore entries for local user accounts. It is critical for developers in
documentation to specify whether an entry is a datastore `id` or a NSS `uid` or `gid` since there have been
several UI bugs where the two were conflated.

NOTE about directory services. Accounts provided by directory services do not have an actual datastore
primary key `id` because they do not get inserted into the accounts tables in the freenas-v1.db database.
They are, however, provided with an `id` when generating a synthetic user or group entry
(see "user.query and group.query" below). This `id` value is created by adding the NSS `uid` or `gid` to
a base constant (`BASE_SYNTHETIC_DATASTORE_ID`) of `100000000`.

`uid` and `gid` values for accounts are obtained from the following sources depending on the account origin.

Local - the `uid` or `gid` value is written to the `/etc/passwd` or `/etc/group` file respectively, which
are written when `etc.generate` `users` is called.

LDAP / IPA - the `uid` or `gid` value is assigned in the LDAP schema of the remote LDAP server. The NSS
modules on TrueNAS prevent honoring values that are less than `1000` to prevent collisions between accounts
on the LDAP server and local system accounts.

Active Directory - by default the LDAP schema in active directory does not explicitly specify `uid` or `gid`
mappings and so the onus is on the system administrator to select reasonable ranges to assign to the AD domain.

NOTE that TrueNAS may have multiple ranges assigned to different active directory domains depending on TrueNAS
configuration and the particulars of the domain to which TrueNAS is joined.


user.get_user_obj and group.get_group_obj
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These APIs retrieve a slightly expanded NSS response for the specified user or group (by either name or uid / gid).
Some key fields:

* Source - whether the account is local or from AD, LDAP, or IPA. This information is used to gate UI / API
  access for directory services accounts to Enterprise editions of truenas.

* Local - whether the account is local. Obtained by determining which NSS module resolved the ID.


user.query and group.query
^^^^^^^^^^^^^^^^^^^^^^^^^^

These APIs retrieve much expanded user account information, and reflect a significant amount of technical debt
from the early days of FreeNAS / TrueNAS. Many fields in the query respone are extended at call time through
datastore extend methods because the fields are implemented in separate database tables from the main account-related
table. The reason why this was adopted is that directory service accounts are not tracked in our database, but
we want users to be able to perform administrative actions such as granting them API keys or configuring two-factor
authentication to TrueNAS. Since many fields here are not available for directory services users and groups, there
are methods in the idmap plugin to create `synthetic_user` and `synthetic_group` based on NSS responses to ensure
API stability. The practical impact of this is that any schema change to user and group entries must also update
those methods for users and groups provided by directory services. NOTE that changes to directory services accounts
through the user and group plugins is explicitly prohibited.


directoryservices.cache
^^^^^^^^^^^^^^^^^^^^^^^

There is a directory services cache plugin that creates and stores the synthetic user and group entries in
tdb files (key-value store provided by the samba suite) in the `/root/tdb/persistent`. The cache is regenerated
daily and may be disabled by administrators. The primary function of this cache is to provide directory services
accounts in user.query and group.query responses. Disabling caching prevents middlewared from enumerating all
users and groups in a directory service and inserting the entries. For a better UX middlewared will still insert
cache entries as accounts are looked up for various reasons (for example when loading permissions forms).


PAM Configuration
=================

TrueNAS uses Linux Pluggable Authentication Modules (PAM) for authentication and session management. While NSS
modules provide account information (passwd/group entries), PAM handles the authentication flow and session
lifecycle. TrueNAS provides three primary PAM service configurations that applications should use depending on
their authentication requirements.


TrueNAS PAM Service Files
--------------------------

All TrueNAS PAM configuration files are defined as Mako templates in
``src/middlewared/middlewared/etc_files/pam.d/`` and are rendered during system configuration to generate the
actual PAM configuration files in ``/etc/pam.d/``. The rendering incorporates system settings such as directory
service authentication state (a licensed feature), STIG mode security settings (including faillock
configuration), and two-factor authentication configuration.


/etc/pam.d/truenas
^^^^^^^^^^^^^^^^^^

This is the primary PAM service for standard username/password authentication through the Web UI and API.

**Authentication flow:**

* When directory service authentication is enabled (licensed feature): Uses the configured directory service
  provider (Active Directory, LDAP, or FreeIPA) and will fall through to local accounts if the directory
  service authentication fails
* When directory service authentication is disabled: Uses local Unix authentication
* Faillock support is enabled when STIG mode is active (independent of directory services)
* Supports optional 2FA via OATH TOTP when enabled
* Includes account validation and session management
* Password changes are denied through this service

**Use this service when:** Your application needs to authenticate users with username and password credentials
in the same manner as the TrueNAS Web UI and API. This is the most common authentication method for interactive
user sessions.


/etc/pam.d/truenas-api-key
^^^^^^^^^^^^^^^^^^^^^^^^^^^

This PAM service is used for authentication with API keys and SCRAM credentials.

**Authentication flow:**

* Authenticates via ``pam_truenas.so`` with support for:

  * Raw API key authentication
  * SCRAM-SHA512 authentication (requires multistep PAM conversation)

* Includes account validation based on directory service configuration
* Faillock support is enabled when STIG mode is active
* Password changes are denied through this service

**Use this service when:** Your application needs to authenticate API requests using API keys or SCRAM-SHA512
authentication. This is appropriate for programmatic access where users have generated API keys through the
TrueNAS interface.


/etc/pam.d/truenas-unix
^^^^^^^^^^^^^^^^^^^^^^^

This PAM service is used for authentication via Unix socket, delegating authentication to the calling
application.

**Authentication flow:**

* Uses ``pam_access.so`` for access control
* No password verification - delegates authentication to the calling application
* Includes account validation based on directory service configuration
* Password changes are denied through this service

**Use this service when:**

* Your application has already authenticated the user through another method (e.g., file upload/download tokens
  where the user authenticated via the Web UI/API first)
* Your application uses SO_PEERCRED to validate the identity of AF_UNIX socket connections
* Your application implements an authentication protocol not currently supported in the PAM layer (e.g., passkey
  authentication)

**Security warning:** This service should not be used without robust security evaluation of the calling
application, as it trusts the application to have performed authentication. The PAM configuration provides no
password verification itself.


Session Management
------------------

All three TrueNAS PAM services support session management through the shared ``/etc/pam.d/truenas-session``
configuration. Applications using these PAM services **must** call ``pam_open_session()`` and
``pam_close_session()`` to properly manage sessions.

Proper session management ensures that:

* Sessions appear in the ``system.security.sessions`` API output
* Sessions are tracked correctly by the middleware
* Session-related security controls (such as concurrent session limits in STIG mode) function properly
* Proper audit trails are maintained

Example session lifecycle in a PAM application::

    pam_handle_t *pamh = NULL;

    // Initialize PAM
    pam_start("truenas", username, &conv, &pamh);

    // Authenticate user
    pam_authenticate(pamh, 0);

    // Validate account
    pam_acct_mgmt(pamh, 0);

    // REQUIRED: Open session
    pam_open_session(pamh, 0);

    // ... application logic ...

    // REQUIRED: Close session
    pam_close_session(pamh, 0);

    // Clean up
    pam_end(pamh, PAM_SUCCESS);


Guidelines for TrueNAS Applications
------------------------------------

TrueNAS-developed applications should follow these guidelines when implementing authentication:

1. **Use TrueNAS PAM services**: Always use one of the three TrueNAS PAM service files (``truenas``,
   ``truenas-api-key``, or ``truenas-unix``) rather than creating custom PAM configurations. This ensures
   consistency with TrueNAS security policies and proper integration with features like directory services, 2FA,
   and STIG mode.

2. **Choose the appropriate service**: Select the PAM service that matches your authentication method:

   * Interactive username/password authentication → ``truenas``
   * API key or SCRAM authentication → ``truenas-api-key``
   * Pre-authenticated or alternative authentication → ``truenas-unix``

3. **Always manage sessions**: Call ``pam_open_session()`` after successful authentication and
   ``pam_close_session()`` when the session ends. Failing to do so will result in sessions not appearing in
   middleware tracking and potential security policy violations.

4. **Respect account validation**: Always call ``pam_acct_mgmt()`` after authentication to ensure the account is
   valid and not locked or expired. Do not bypass this step.

5. **Handle faillock correctly**: When STIG mode is enabled, failed authentication attempts are tracked via
   faillock. Applications must properly handle PAM authentication failures to ensure users are locked out after
   repeated failures.

6. **Do not implement custom authentication**: If you need an authentication method not supported by the existing
   TrueNAS PAM services, discuss with the middleware team rather than implementing a custom solution. The
   ``truenas-unix`` service exists for cases where authentication happens outside PAM, but this requires careful
   security review.


Example: Simple PAM Authentication
-----------------------------------

Here is a minimal example of authenticating a user via the ``truenas`` PAM service in Python using the
``truenas_authenticator`` library::

    from truenas_authenticator import UserPamAuthenticator
    from middlewared.utils.account.authenticator import TruenasPamFile

    # Create authenticator
    auth = UserPamAuthenticator(username, TruenasPamFile.DEFAULT.service)

    try:
        # Perform authentication
        response = auth.authenticate(password)

        if response.pam_code == PAMCode.PAM_SUCCESS:
            # Open session (REQUIRED)
            session_response = auth.start_session()

            if session_response.pam_code == PAMCode.PAM_SUCCESS:
                # Session is now active and tracked
                # ... application logic ...

                # Close session when done (REQUIRED)
                auth.end_session()
        else:
            # Authentication failed
            print(f"Authentication failed: {response.message}")

    finally:
        # Clean up PAM handle
        auth.close()


Common Pitfalls
---------------

1. **Forgetting session management**: Applications that authenticate but don't call ``pam_open_session()`` will
   not appear in ``system.security.sessions`` and will not be subject to session-based security controls.

2. **Using the wrong service file**: Using ``truenas-unix`` when you should use ``truenas`` bypasses password
   verification entirely. Only use ``truenas-unix`` when authentication has already occurred through a secure
   alternative mechanism.

3. **Creating custom PAM configurations**: Don't create application-specific PAM files like
   ``/etc/pam.d/myapp``. Use the TrueNAS services to ensure consistency with system security policies.

4. **Ignoring account validation**: Always call ``pam_acct_mgmt()`` after authentication. An account may
   authenticate successfully but still be locked, expired, or otherwise invalid.

5. **Hardcoding PAM service names**: Use the constants defined in
   ``middlewared.utils.account.authenticator.TruenasPamFile`` rather than hardcoding service names as strings.


Identity providers and TrueNAS features
=======================================

The interaction between accounts from the configured NSS modules and features / services provided by the TrueNAS
server are complex. An example is when a service defines a guest account or overrides NSS responses when generating
internal user account tokens ("unix token" in following discussion). What follows is a rough overview of this
interaction on a per-service basis.

NOTE: applications will often not regenerate unix tokens after initial authentication. This means that sessions
may need to be terminated in order to see changes in user group membership.


Middlewared
-----------

All accounts used in middlewared sessions are provided by an NSS module. Guest access and guest accounts are not
permitted. Group membership is determined when account authenticates, but is not re-evaluated during the session
lifetime.


SMB
---

All accounts used by the SMB server are provided by one or more NSS modules. Guest access is configurable, but
off by default. The administrator must specify a valid existing account on the truenas server for the guest
account, which defaults to `nobody`. Server administrators may override the default unix token for local accounts
by using share or global auxiliary parameters in the SMB configuration (though this is discouraged and unsupported).
When kerberos authentication is used, the unix token is generated from the client kerberos ticket. Unix tokens are
generated when the client authenticates and connects to a share and are not re-evaluated for the lifetime of
the connection.


NFS
---

How the Unix token for an NFS client is constructed depends on the particulars of the server configuration. The list
of gids for a unix token is either determined client-side or server-side depending on the value of the userd_manage_gids
key in the `nfs.config`. If kerberos authentication is used, then the unix token is constructed based on the client
kerberos ticket. The unix token is not re-evaluated for the lifetime of the NFS "session".


FTP
---

All accounts used by the FTP server are provided by one or more NSS modules. Guest access is configurable.
The unix token is not re-evaluated for the lifetime of the FTP session. NOTE that not all NSS-provided accounts
will be able to authenticate to the FTP server.


SSH
---

All accounts used by the SSH server are provided by one or more NSS modules. The unix token is not re-evaluated for the
lifetime of the SSH session. NOTE that not all NSS-provided accounts will be able to authenticate to the SSH server.


Apps and containers
-------------------

There is no interaction between the host identity providers and accounts in apps containers.
