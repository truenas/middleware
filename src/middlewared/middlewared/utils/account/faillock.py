# Utilities related to the faillock tally files generated by pam_faillock(8)

import enum
import os
from dataclasses import dataclass
from struct import unpack
from middlewared.utils.time_utils import utc_now
from typing import Generator


FAILLOCK_DIR = '/var/run/faillock'

# Each faillock tally file is comprised of zero or more tally entries
#
# struct  tally {
#         char            source[52];     /* rhost or tty of the login failure */
#                                         /* (not necessarily NULL terminated) */
#         uint16_t        reserved;       /* reserved for future use */
#         uint16_t        status;         /* record status  */
#         uint64_t        time;           /* time of the login failure */
# };

STRUCT_TALLY = '52sHHQ'
TALLY_ENTRY_SZ = 64
MAX_FAILURE = 3
FAIL_INTERVAL = 15 * 60
UNLOCK_TIME = 15 * 60


class TallyStatus(enum.IntFlag):
    VALID = 0x1
    RHOST = 0x2
    TTY = 0x4


@dataclass(slots=True, frozen=True)
class TallyEntry:
    source: str
    status: TallyStatus
    timestamp: int  # 64bit time_t


def has_tally(username: str) -> bool:
    try:
        st = os.stat(os.path.join(FAILLOCK_DIR, username))
    except FileNotFoundError:
        return False

    # NOTE: pam_faillock will reset tally file via ftruncate(tally_fd, 0)
    return st.st_size > 0


def reset_tally(username: str) -> None:
    """ Reset the tally file so that temporary account lock is removed. This function
    is used in user.update in order to provide admin a mechanism to remove a temporary
    lock. NOTE: behavior matches reset_tally() in pam_faillock.c in that it does not perform
    any locking before truncation."""
    try:
        fd = os.open(os.path.join(FAILLOCK_DIR, username), os.O_RDWR)
    except FileNotFoundError:
        pass
    else:
        try:
            os.ftruncate(fd, 0)
        finally:
            os.close(fd)


def iter_tally(username: str) -> Generator[TallyEntry]:
    try:
        with open(os.path.join(FAILLOCK_DIR, username), 'rb') as f:
            while data := f.read(TALLY_ENTRY_SZ):
                unpacked = unpack(STRUCT_TALLY, data)
                yield TallyEntry(unpacked[0].strip(b'\x00').decode(), TallyStatus(unpacked[2]), unpacked[3])

    except FileNotFoundError:
        # Nothing to do. No tally entries
        pass


def is_tally_locked(username: str, unlock_time: int = UNLOCK_TIME) -> bool:
    """ Return boolean for whether the specified account name has been locked by
    pam_faillock """
    failures = 0
    last_time = 0
    entries = []

    for entry in iter_tally(username):
        if entry.timestamp > last_time:
            last_time = entry.timestamp

        entries.append(entry)

    if not last_time:
        # Short-circuit if no entries
        return False

    if int(utc_now(naive=False).timestamp()) > (last_time + unlock_time):
        # Short-circuit if timeout has expired
        return False

    for entry in entries:
        if entry.status & TallyStatus.VALID.value and (last_time - entry.timestamp) < FAIL_INTERVAL:
            failures += 1
            if failures >= MAX_FAILURE:
                return True

    return False


def tally_locked_users() -> set[str]:
    """ Return set of user names of users who are locked due to tally limits
    defined by pam_faillock """
    out = set()

    if not os.path.exists(FAILLOCK_DIR):
        # pam_faillock(8) may not have created the directory yet. If it doesn't
        # exist then we can short-circuit. There's no need to create the directory.
        return out

    with os.scandir(FAILLOCK_DIR) as it:
        for dirent in it:
            if is_tally_locked(dirent.name):
                out.add(dirent.name)

    return out
