<%
	import os

	from collections import defaultdict

	global_config = middleware.call_sync('iscsi.global.config')
	targets = middleware.call_sync('iscsi.target.query')
	extents = {d['id']: d for d in middleware.call_sync('iscsi.extent.query', [['enabled', '=', True]])}
	portals = {d['id']: d for d in middleware.call_sync('iscsi.portal.query')}
	initiators = {d['id']: d for d in middleware.call_sync('iscsi.initiator.query', [['initiators', '!=', []]])}
	associated_targets = defaultdict(list)
	for a_tgt in filter(lambda a: a['extent'] in extents, middleware.call_sync('iscsi.targetextent.query')):
		associated_targets[a_tgt['target']].append(a_tgt)

	# Let's map extents to respective ios
	extents_io = {'vdisk_fileio': [], 'vdisk_blockio': [], 'dev_disk': []}
	for extent in extents.values():
		if extent['type'] == 'DISK':
			extent['extent_path'] = os.path.join('/dev', extent['disk'])
			extents_io['vdisk_blockio'].append(extent)
			# dev_disk is pass-through which we would be using for disks
			# FIXME: It is however showing kernel dumps
			# So for now we use blockio for disks as well
		else:
			extent['extent_path'] = extent['path']
			extents_io['vdisk_fileio'].append(extent)
	# FIXME: SSD is not being reflected in the initiator, please look into it
	# FIXME: Authorized networks for initiators has not been implemented yet, please look for alternatives in SCST
%>\
% for handler in filter(lambda k: extents_io[k], extents_io):
HANDLER ${handler} {
%	for extent in extents_io[handler]:
	DEVICE ${extent['name']} {
		filename ${extent['extent_path']}
		blocksize ${extent['blocksize']}
		read_only ${'1' if extent['ro'] else '0'}
		usn ${extent['serial']}
		naa_id ${extent['naa']}
		prod_id "iSCSI Disk"
%		if extent['rpm'] != 'SSD':
		rotational ${extent['rpm']}
%		endif
	}

%	endfor
}
% endfor

TARGET_DRIVER iscsi {
	enabled 1

<%def name="retrieve_luns(target_id, spacing='')">
	% for associated_target in associated_targets[target_id]:
		${spacing}LUN ${associated_target['lunid']} ${extents[associated_target['extent']]['name']}
	% endfor
</%def>\
% for target in targets:
	TARGET ${global_config['basename']}:${target['name']} {
%	if associated_targets:
		enabled 1
%	endif
%	for group in target['groups']:
<%
	addresses = []
	for addr in portals[group['portal']]['listen']:
		if addr['ip'] == '0.0.0.0':
			# SCST uses wildcard patterns
			# FIXME: Please investigate usage of ipv6 patterns
			# https://github.com/truenas/scst/blob/e945943861687d16ae0415207306f75a55bcfd2b/iscsi-scst/usr/target.c#L139-L138
			addresses = []
			break
		addresses.append({**addr, 'ip': f'[{addr["ip"]}]' if ':' in addr['ip'] else addr['ip']})
		# FIXME: SCST does not seem to respect port values for portals, please look for alternatives
		# Refer to above git link please for this fixme
%>\
		% for addr in addresses:
		allowed_portal ${addr['ip']}
		% endfor
%	endfor
%	if any(g['initiator'] not in initiators for g in target['groups']):
${retrieve_luns(target['id'])}\
%	else:
%		for group in target['groups']:
		GROUP ${target['name']}_${group['initiator']} {
%			for initiator in initiators[group['initiator']]['initiators']:
			INITIATOR ${initiator}
%			endfor
${retrieve_luns(target['id'], '\t')}\
		}
%		endfor
%	endif
	}
% endfor
}
