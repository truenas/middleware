from datetime import datetime
from typing import Any, Literal, Union

from pydantic import Field, Secret

from middlewared.api.base import BaseModel, single_argument_args, single_argument_result
from middlewared.utils.auth import AuthMech, AuthResp
from .user import UserGetUserObj


__all__ = [
    'AuthSessionsEntry', 'AuthGenerateOnetimePasswordArgs', 'AuthGenerateOnetimePasswordResult',
    'AuthGenerateTokenArgs', 'AuthGenerateTokenResult', 'AuthLoginArgs', 'AuthLoginResult', 'AuthLoginExArgs',
    'AuthLoginExResult', 'AuthLoginExContinueArgs', 'AuthLoginExContinueResult', 'AuthLoginWithApiKeyArgs',
    'AuthLoginWithApiKeyResult', 'AuthLoginWithTokenArgs', 'AuthLoginWithTokenResult', 'AuthMeArgs', 'AuthMeResult',
    'AuthMechanismChoicesArgs', 'AuthMechanismChoicesResult', 'AuthLogoutArgs', 'AuthLogoutResult',
    'AuthSetAttributeArgs', 'AuthSetAttributeResult', 'AuthTerminateOtherSessionsArgs',
    'AuthTerminateOtherSessionsResult', 'AuthTerminateSessionArgs', 'AuthTerminateSessionResult',
]


class BaseCredentialData(BaseModel):
    pass


class UserCredentialData(BaseCredentialData):
    username: str
    """Username of the authenticated user."""
    login_id: str
    """ Unique identifier for the login. """
    login_at: datetime
    """Timestamp of when the user logged in."""


class APIKeySessionData(BaseModel):
    id: int
    """Unique identifier for the API key."""
    name: str
    """Human-readable name of the API key."""


class APIKeyCredentialData(UserCredentialData):
    api_key: APIKeySessionData
    """API key information used for authentication."""


class TokenCredentialData(BaseCredentialData):
    parent: 'TokenParentCredentialsData'
    """Parent credential information that generated this token."""
    login_id: str
    """ Unique identifier for the login. """
    username: str | None
    """Username associated with the token. `null` if not user-specific."""


class AuthSessionsEntry(BaseModel):
    id: str
    """Unique identifier for the authentication session."""
    current: bool
    """Whether this is the current active session."""
    internal: bool
    """Whether this is an internal system session."""
    origin: str
    """Origin information for the session (IP address, hostname, etc.)."""
    credentials: Literal[
        'UNIX_SOCKET',
        'LOGIN_PASSWORD',
        'LOGIN_TWOFACTOR',
        'LOGIN_ONETIME_PASSWORD',
        'API_KEY',
        'TOKEN',
        'TRUENAS_NODE',
    ]
    """Authentication method used for this session.

    * `UNIX_SOCKET`: Local Unix domain socket authentication
    * `LOGIN_PASSWORD`: Username and password authentication
    * `LOGIN_TWOFACTOR`: Two-factor authentication login
    * `LOGIN_ONETIME_PASSWORD`: One-time password authentication
    * `API_KEY`: API key authentication
    * `TOKEN`: Token-based authentication
    * `TRUENAS_NODE`: TrueNAS cluster node authentication
    """
    credentials_data: BaseCredentialData | UserCredentialData | APIKeyCredentialData | TokenCredentialData
    """Detailed credential information specific to the authentication method."""
    created_at: datetime
    """Timestamp when the session was created."""
    secure_transport: bool
    """Whether the session was established over a secure transport (HTTPS/WSS)."""


class AuthCommonOptions(BaseModel):
    user_info: bool = True  # include auth.me in successful result
    """Whether to include detailed user information in the authentication response."""


class AuthApiKeyPlain(BaseModel):
    mechanism: Literal[AuthMech.API_KEY_PLAIN]
    """Authentication mechanism identifier for plain API key authentication."""
    username: str
    """Username associated with the API key."""
    api_key: Secret[str]
    """API key for authentication."""
    login_options: AuthCommonOptions = AuthCommonOptions()
    """Additional options for the authentication process."""


class ScramClientInit(BaseModel):
    """ The initial SCRAM client payload to the TrueNAS server. Initiates authentication.  """
    stage: Literal['INIT']
    username: str
    """Username associated with the API key."""
    api_key_id: int
    """API key ID for authentication. This is provided when the API key is initially generated.

    API keys generated by earlier TrueNAS versions may have been formatted like the following:
    1-VqZfWCloeIoYsJbquX7BGaD45JBtOUx0NFHxg5ll7e4QLH1cG5XTtdGU0KbBxxRL. In this example the
    `api_key_id` is `1` and the `api_key_data` is `1-VqZfWCloeIoYsJbquX7BGaD45JBtOUx0NFHxg5ll7e4QLH1cG5XTtdGU0KbBxxRL`.
    """
    nonce: str
    """Base64 encoded random bytes (32) generated client-side."""`
    login_options: AuthCommonOptions = AuthCommonOptions()
    """Additional options for the authentication process."""


class ScramClientFinal(BaseModel):
    """ The final SCRAM client payload to the TrueNAS server. This message furnishes a `client_proof` to
    the server to prove that the client has access to the `client_key` and `stored_key`.
    """
    stage: Literal['FINAL']
    nonce: str
    """Copy of the nonce from the initial TrueNAS server response to the initial client request."""
    client_proof: NonEmptyString
    """Base64 encoded client proof. The client proof is generated by the following procedure:

    1. Create the AuthMessage through the following procedure
    1a. Build the `client-first-message-bare` string using the username and nonce from the first client message:
        `"n=<username>,r=<nonce>"`
        For example: `"n=bob,r=H96RWF04Q6QhW9nUrdMexBJFbpgOM1aYVrP8uUi4+fY="`
    1b. Build the `server-first-message` string using the first server response:
        `"r=<server response nonce>,s=<server salt>,i=<server iterations>"`
        For example:
        `"r=H96RWF04Q6QhW9nUrdMexBJFbpgOM1aYVrP8uUi4+faOZ5LIg7DHCBaSdgOrSMw+FQN+0KTrGw5rVEvKmIkSeQ==,
        s=OU9jM3RlbjBjZUNFUk1QLw==,i=500000"`
    1c. Build the `client-final-message-without-proof` string as follows:
        `"c=biws,r=<server response nonce>"`
        For example:
        `"c=biws,r=H96RWF04Q6QhW9nUrdMexBJFbpgOM1aYVrP8uUi4+faOZ5LIg7DHCBaSdgOrSMw+FQN+0KTrGw5rVEvKmIkSeQ=="`
    1d. Concatenate the strings from (1a), (1b), and (1c) as follows:
        `"<client-first-message-bare>,<server-first-message>,<client-final-message-without-proof>"`

        So using the examples provided earlier, the AuthmMessage will be the following string:
        `"n=bob,r=H96RWF04Q6QhW9nUrdMexBJFbpgOM1aYVrP8uUi4+fY=,
        r=H96RWF04Q6QhW9nUrdMexBJFbpgOM1aYVrP8uUi4+faOZ5LIg7DHCBaSdgOrSMw+FQN+0KTrGw5rVEvKmIkSeQ==,
        s=OU9jM3RlbjBjZUNFUk1QLw==,i=500000,
        c=biws,r=H96RWF04Q6QhW9nUrdMexBJFbpgOM1aYVrP8uUi4+faOZ5LIg7DHCBaSdgOrSMw+FQN+0KTrGw5rVEvKmIkSeQ=="`

    2. Create the ClientSignature by applying the HMAC keyed hash algorithm to generate a digest using
       the AuthMessage from (1) for the `stored_key` using the sha512 hashing function.
       Using python this can be generated through `hmac.digest(stored_key, AuthMessage, hashlib.sha512)`.

    3. Create the `client_proof` by exclusive-ORing the `client_key` and ClientSignature from (2).
    """


class AuthApiKeyScram(BaseModel):
    """
    Authenticate to the TrueNAS server using SCRAM-SHA512. Authentication involves sending two client
    messages and parsing two server responses.

    Client - INIT stage message
    Server - INIT stage response
    Client - FINAL stage message
    Server - FINAL stage respones

    NOTE: During the course of SCRAM authentication, the client will need access to the `client_key` and
    `stored_key` that were generated when the API key was first created. If validation of the final server
    message is desired, then the `server_key` is also required.

    If the API key was created prior to SCRAM support being added to TrueNAS or if the client only has access to the
    plain-text of the API key, then the `stored_key` and `client_key` may be generated as follows:

    1. Send `INIT` stage message from the client to the server to obtain the salt and iteration count
       to generate a `SaltedPassword` per RFC5802.

    2. Use the salt, iteration count, and known plain-text API key to generate the `client_key` and `stored_key` as
       follows. NOTE: the `api_key` returned by the TrueNAS server in earlier releases was formatted like
       1-VqZfWCloeIoYsJbquX7BGaD45JBtOUx0NFHxg5ll7e4QLH1cG5XTtdGU0KbBxxRL. The `-` character separates the API key
       ID from the API key data.

    2a. Derive a key for API key using pbkdf2_hmac with sha512 using the server-provided salt and iteration count.
        Using python this can be generated using `hashlib.pbkdf2_hmac("sha512", api_key_data, decoded_salt, iterations)`

    2b. Generate `client_key` by applying the HMAC keyed hash algorithm to generate a digest `"Client Key"` for the
        key in (2a) above using the the sha512 hashing function.
        Using python this can be generated using `hmac.digest(derived_key, b"Client Key", hashlib.sha512)`

    2c. `stored_key` is a sha512 digest of the derived key generated in 2a above.
        Using python this can be generated throuhg `hashlib.sha512(derived_key).digest()`.

    2d. Generate `server_key` by applying the HMAC keyed hash algorithm to generate a digest `"Server Key"` for the
        key in (2a) above using the the sha512 hashing function.
        Using python this can be generated using `hmac.digest(derived_key, b"Server Key", hashlib.sha512)`
    """
    mechanism: Literal[AuthMech.API_KEY_SCRAM]
    """Authentication mechanism identifier for plain API key authentication."""
    data: ScramClientInit | ScramClientFinal = Field(discriminator='stage')


class AuthLegacyUsernamePassword(BaseModel):
    username: str
    """Username for authentication."""
    password: Secret[str]
    """Password for authentication."""


class AuthOTPToken(BaseModel):
    mechanism: Literal[AuthMech.OTP_TOKEN]
    """Authentication mechanism identifier for one-time password tokens."""
    otp_token: Secret[str]
    """One-time password token for authentication."""
    login_options: AuthCommonOptions = AuthCommonOptions()
    """Additional options for the authentication process."""


class AuthPasswordPlain(BaseModel):
    mechanism: Literal[AuthMech.PASSWORD_PLAIN]
    """Authentication mechanism identifier for plain password authentication."""
    username: str
    """Username for authentication."""
    password: Secret[str]
    """Password for authentication."""
    login_options: AuthCommonOptions = AuthCommonOptions()
    """Additional options for the authentication process."""


class AuthRespAuthErr(BaseModel):
    response_type: Literal[AuthResp.AUTH_ERR]
    """Authentication response type indicating authentication failure."""


class AuthRespAuthRedirect(BaseModel):
    response_type: Literal[AuthResp.REDIRECT]
    """Authentication response type indicating redirect is required."""
    urls: list[str]
    """Array of URLs to redirect to for authentication completion."""


class AuthRespExpired(BaseModel):
    response_type: Literal[AuthResp.EXPIRED]
    """Authentication response type indicating the session or token has expired."""


class AuthRespOTPRequired(BaseModel):
    response_type: Literal[AuthResp.OTP_REQUIRED]
    """Authentication response type indicating one-time password is required."""
    username: str
    """Username for which OTP is required."""


class AuthUserInfo(UserGetUserObj):
    attributes: dict
    """Custom user attributes and metadata."""
    two_factor_config: dict
    """Two-factor authentication configuration for the user."""
    privilege: dict
    """User privilege and role information."""
    account_attributes: list[str]
    """Array of account attribute names available for this user."""


class ScramServerInit(BaseModel):
    stage: Literal['INIT']
    salt: str
    """Base64 string containing salt for client to use for next auth stage."""
    iteration_count: int
    """Number of iterations of pbkdf2_hmac with sha512 to perform on API key."""
    nonce: str
    """Client nonce provided in initial client message with appeneded server nonce."""


class ScramServerFinal(BaseModel):
    stage: Literal['FINAL']
    signature: str
    """Server signature providing proof that it has access to `server_key` associated
    with the `client_key` that generated the `client_proof` in the final SCRAM client message.

    NOTE: The client needs access to the `server_key` in order to validate the final server
    signature (if desired).
    """
    user_info: AuthUserInfo | None
    """Authenticated user information or `null` if not available."""
    authenticator: Literal['LEVEL_2']
    """Authentication level achieved."""


class AuthRespScram(BaseModel):
    response_type: Literal[AuthResp.SCRAM_RESPONSE]
    """Authentication response type for SCRAM authentication."""
    data: ScramServerInit | ScramServerFinal = Field(discriminator='stage')


class AuthRespSuccess(BaseModel):
    response_type: Literal[AuthResp.SUCCESS]
    """Authentication response type indicating successful login."""
    user_info: AuthUserInfo | None
    """Authenticated user information or `null` if not available."""
    authenticator: Literal['LEVEL_1', 'LEVEL_2']
    """Authentication level achieved (LEVEL_1 for password, LEVEL_2 for two-factor)."""


class AuthTokenPlain(BaseModel):
    mechanism: Literal[AuthMech.TOKEN_PLAIN]
    """Authentication mechanism type for plain token login."""
    token: Secret[str]
    """Authentication token (masked for security)."""
    login_options: AuthCommonOptions = AuthCommonOptions()
    """Common authentication options and settings."""


class TokenParentCredentialsData(BaseModel):
    credentials: Literal[
        'UNIX_SOCKET',
        'LOGIN_PASSWORD',
        'LOGIN_TWOFACTOR',
        'API_KEY',
        'TOKEN',
        'TRUENAS_NODE',
    ]
    """Type of credentials used to generate this token."""
    credentials_data: BaseCredentialData | UserCredentialData | APIKeyCredentialData | TokenCredentialData
    """Credential data used to authenticate the token request."""


@single_argument_args('generate_single_use_password')
class AuthGenerateOnetimePasswordArgs(BaseModel):
    username: str
    """Username to generate a one-time password for."""


class AuthGenerateOnetimePasswordResult(BaseModel):
    result: str
    """Generated one-time password for the specified user."""


class AuthGenerateTokenArgs(BaseModel):
    ttl: int | None = 600
    """Time-to-live for the token in seconds or `null` for no expiration (default 600)."""
    attrs: dict = {}  # XXX should we have some actual validation here?
    """Additional attributes to embed in the token."""
    match_origin: bool = True  # NOTE: this is change in default from before 25.04
    """Whether the token must be used from the same origin that created it."""
    single_use: bool = False
    """Whether the token can only be used once."""


class AuthGenerateTokenResult(BaseModel):
    result: str
    """Generated authentication token."""


class AuthLoginArgs(AuthLegacyUsernamePassword):
    otp_token: Secret[str | None] = None
    """One-time password token for two-factor authentication or `null`."""


class AuthLoginResult(BaseModel):
    result: bool
    """Returns `true` if login was successful, `false` otherwise."""


class AuthLoginExArgs(BaseModel):
    login_data: AuthApiKeyPlain | AuthPasswordPlain | AuthTokenPlain | AuthOTPToken = Field(discriminator='mechanism')
    """Authentication data specifying mechanism and credentials."""


class AuthLoginExResult(BaseModel):
    result: Union[
        AuthRespSuccess, AuthRespAuthErr, AuthRespExpired, AuthRespOTPRequired, AuthRespAuthRedirect
    ] = Field(discriminator='response_type')
    """Authentication response indicating success, failure, or additional steps required."""


class AuthLoginExContinueArgs(BaseModel):
    login_data: AuthOTPToken
    """OTP token data to continue two-factor authentication flow."""


class AuthLoginExContinueResult(BaseModel):
    result: Union[
        AuthRespSuccess, AuthRespAuthErr, AuthRespExpired, AuthRespOTPRequired, AuthRespAuthRedirect
    ] = Field(discriminator='response_type')
    """Authentication response after continuing with OTP token."""


class AuthLoginWithApiKeyArgs(BaseModel):
    api_key: Secret[str]
    """API key for authentication (masked for security)."""


class AuthLoginWithApiKeyResult(BaseModel):
    result: bool
    """Returns `true` if API key login was successful, `false` otherwise."""


class AuthLoginWithTokenArgs(BaseModel):
    token: Secret[str]
    """Authentication token (masked for security)."""


class AuthLoginWithTokenResult(BaseModel):
    result: bool
    """Returns `true` if token login was successful, `false` otherwise."""


class AuthMeArgs(BaseModel):
    pass


@single_argument_result
class AuthMeResult(AuthUserInfo):
    pass


class AuthMechanismChoicesArgs(BaseModel):
    pass


class AuthMechanismChoicesResult(BaseModel):
    result: list[str]
    """Array of available authentication mechanisms."""


class AuthLogoutArgs(BaseModel):
    pass


class AuthLogoutResult(BaseModel):
    result: Literal[True]
    """Returns `true` when logout is successful."""


class AuthSetAttributeArgs(BaseModel):
    """WebUI attributes."""
    key: str
    """Attribute key name."""
    value: Any
    """Attribute value to set."""


class AuthSetAttributeResult(BaseModel):
    result: Literal[None]
    """Returns `null` when the attribute is successfully set."""


class AuthTerminateOtherSessionsArgs(BaseModel):
    pass


class AuthTerminateOtherSessionsResult(BaseModel):
    result: Literal[True]
    """Returns `true` when other sessions are successfully terminated."""


class AuthTerminateSessionArgs(BaseModel):
    id: str
    """Session ID to terminate."""


class AuthTerminateSessionResult(BaseModel):
    result: bool
    """Returns `true` if the session was successfully terminated, `false` otherwise."""
