import pam
import re

from dataclasses import dataclass
from datetime import datetime, UTC
from middlewared.utils.allowlist import Allowlist
from middlewared.utils.account.authenticator import (
    DEFAULT_LOGIN_FAIL, DEFAULT_LOGIN_SUCCESS,
    DEFAULT_LOGOUT_FAIL, DEFAULT_LOGOUT_SUCCESS,
    UserPamAuthenticator, ApiKeyPamAuthenticator, UnixPamAuthenticator,
    TrueNASAuthenticatorResponse,
)
from middlewared.utils.origin import ConnectionOrigin
from middlewared.utils.auth import AuthMech, AuthenticatorAssuranceLevel
from middlewared.utils.crypto import ssl_uuid4
from time import monotonic


class SessionManagerCredentials:
    is_user_session = False
    may_create_auth_token = True
    allowlist = None
    login_id = None

    @classmethod
    def class_name(cls):
        return re.sub(
            r"([A-Z])",
            r"_\1",
            cls.__name__.replace("SessionManagerCredentials", "")
        ).lstrip("_").upper()

    def login(self, session_id: str) -> TrueNASAuthenticatorResponse:
        # Default to failure. This method should not be hit
        return DEFAULT_LOGIN_FAIL

    def is_valid(self):
        return True

    def authorize(self, method, resource):
        return False

    def has_role(self, role):
        return False

    def notify_used(self):
        pass

    def logout(self) -> TrueNASAuthenticatorResponse:
        return DEFAULT_LOGOUT_FAIL

    def dump(self):
        return {}


class UserSessionManagerCredentials(SessionManagerCredentials):
    """ Credentials for authenticated user session """

    def __init__(
        self,
        user: dict,
        assurance: AuthenticatorAssuranceLevel | None,
        authenticator: UserPamAuthenticator,
    ):
        """
        user: dictionary generated by `auth.authenticate_user`

        assurance: authenticator assurance level for the session. This
        may be None if the session is authenticated by virtue of unix domain
        socket connection.

        Our default is AAL1 which allows authenticated sessions to use
        credentials for up to 30 days before requiring reauthentication, and
        does not set an inactivity timeout.

        See comments in utils/auth.py for more information.
        """
        now = monotonic()
        self.user = user
        self.assurance = assurance
        self.allowlist = Allowlist(user["privilege"]["allowlist"])
        self.is_user_session = True
        self.login_at = datetime.now(UTC)
        self.expiry = None
        self.inactivity_timeout = None
        self.last_used_at = now
        self.authenticator = authenticator

        if assurance:
            self.expiry = now + self.assurance.max_session_age
            self.inactivity_timeout = self.assurance.max_inactivity

    def login(self, session_id: str) -> TrueNASAuthenticatorResponse:
        resp = self.authenticator.login(session_id)
        self.login_at = self.authenticator.login_at
        self.login_id = str(ssl_uuid4())
        return resp

    def logout(self) -> TrueNASAuthenticatorResponse:
        resp = self.authenticator.logout()
        self.authenticator = None
        return resp

    def notify_used(self):
        if self.inactivity_timeout:
            now = monotonic()
            if now < self.last_used_at + self.inactivity_timeout:
                self.last_used_at = now

    def is_valid(self):
        if self.assurance and (now := monotonic()) > self.expiry:
            return False

        if self.inactivity_timeout:
            if now > self.last_used_at + self.inactivity_timeout:
                return False

        return True

    def authorize(self, method, resource):
        if not self.is_valid():
            return False

        return self.allowlist.authorize(method, resource)

    def has_role(self, role):
        return role in self.user["privilege"]["roles"]

    def dump(self):
        return {
            "username": self.user["username"],
            "login_id": self.login_id,
            "login_at": self.login_at
        }


class ApiKeySessionManagerCredentials(UserSessionManagerCredentials):
    """ Credentials for a specific user account on TrueNAS
    Authenticated by user-linked API key
    """

    def __init__(
        self,
        user: dict,
        api_key: dict,
        assurance: AuthenticatorAssuranceLevel,
        authenticator: ApiKeyPamAuthenticator
    ):
        super().__init__(user, assurance, authenticator)
        self.api_key = api_key

    def dump(self):
        out = super().dump()
        return out | {
            "api_key": {
                "id": self.api_key["id"],
                "name": self.api_key["name"],
            }
        }


class UnixSocketSessionManagerCredentials(UserSessionManagerCredentials):
    """ Credentials for a specific user account on TrueNAS
    Authenticated by unix domain socket connection
    """
    def __init__(self, user: dict, authenticator: UnixPamAuthenticator):
        super().__init__(user, None, authenticator)


class LoginPasswordSessionManagerCredentials(UserSessionManagerCredentials):
    """ Credentials for a specific user account on TrueNAS
    Authenticated by username + password combination.
    """
    def __init__(
        self,
        user: dict,
        assurance: AuthenticatorAssuranceLevel,
        authenticator: UserPamAuthenticator
    ):
        super().__init__(user, assurance, authenticator)


class LoginTwofactorSessionManagerCredentials(LoginPasswordSessionManagerCredentials):
    """ Credentials for a specific user account on TrueNAS
    Authenticated by username + password combination and additional
    OTP token.
    """
    pass


class LoginOnetimePasswordSessionManagerCredentials(UserSessionManagerCredentials):
    """ Credentials for a specific user account  on TrueNAS
    Authenticated by username + onetime password ccombination
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.may_create_auth_token = False


class TokenSessionManagerCredentials(SessionManagerCredentials):
    """ Credentials generated by auth.generate_token, auth.get_token_for_action,
    or auth.get_token_for_shell_action. Authentication is based on having correct
    token string, c.f. token, and authorization is based on the "root credential" that
    initially generated the token. """
    def __init__(
        self,
        token_manager,
        token,
        authenticator: UnixPamAuthenticator,
        origin: ConnectionOrigin,
    ):
        self.root_credentials = token.root_credentials()
        """ Root credentials for the token are the credentials used for originally
        generating it. These are used for method authorization. """
        self.authenticator = authenticator
        """ The PamAuthenticator generated for the middleware session that is
        using the token (already authenticated by providing the token string) """
        self.origin = origin
        """ A reference for the origin of this connection is required in order
        to ensure that PAM auditd entries properly account for the remote host
        that is using the token. """

        self.token_manager = token_manager
        self.token = token
        self.is_user_session = self.root_credentials.is_user_session
        self.login_at = datetime.now(UTC)
        self.pam_authenticated = False

        # Middleware has already determined that the token string matches, but
        # we still need to generate the utmp entry
        if self.is_user_session:
            self.user = self.root_credentials.user

        self.allowlist = self.root_credentials.allowlist

    def pam_authenticate(self):
        """ Perform PAM authentication for the account. This may fail if the underlying
        account is locked or if it account session limits have been reached c.f. pam_limits.
        This also generates utmp entry for the token-based session. """
        assert self.pam_authenticated is False

        username = self.user['username'] if self.is_user_session else 'root'
        pam_resp = self.authenticator.authenticate(username, self.origin)
        self.pam_authenticated = pam_resp.code == pam.PAM_SUCCESS
        return pam_resp

    def is_valid(self):
        if not self.root_credentials.is_valid():
            return False

        if not self.pam_authenticated:
            # Somehow the pam_authenticate stage was skipped or we failed to
            # properly check when we generated credentials
            return False

        return self.token.is_valid()

    def authorize(self, method, resource):
        return self.token.parent_credentials.authorize(method, resource)

    def has_role(self, role):
        return self.token.parent_credentials.has_role(role)

    def notify_used(self):
        self.root_credentials.notify_used()
        self.token.notify_used()

    def login(self, session_id: str) -> TrueNASAuthenticatorResponse:
        resp = self.authenticator.login(session_id)
        self.login_at = self.authenticator.login_at
        self.login_id = str(ssl_uuid4())
        return resp

    def logout(self) -> TrueNASAuthenticatorResponse:
        # Remove reference to parent authenticator
        self.token_manager.destroy(self.token)
        # Explicit logout of this session
        return self.authenticator.logout()

    def dump(self):
        data = {
            "parent": dump_credentials(self.token.parent_credentials),
            "login_id": self.login_id,
            "username": None
        }
        if self.is_user_session:
            data["username"] = self.user["username"]

        return data


class TruenasNodeSessionManagerCredentials(SessionManagerCredentials):
    """ Authentication from other HA node """
    def login(self, session_id: str) -> TrueNASAuthenticatorResponse:
        return DEFAULT_LOGIN_SUCCESS

    def logout(self) -> TrueNASAuthenticatorResponse:
        return DEFAULT_LOGOUT_SUCCESS

    def authorize(self, method, resource):
        return True


@dataclass()
class AuthenticationContext:
    """
    This stores PAM context for authentication mechanisms that implement
    challenge-response protocol. We need to keep reference for PAM handle
    to handle any required PAM conversations.
    """
    pam_hdl: UserPamAuthenticator | ApiKeyPamAuthenticator | UnixPamAuthenticator | None = None
    next_mech: AuthMech | None = None
    auth_data: dict | None = None


class FakeApplication:
    authenticated_credentials = SessionManagerCredentials()


def fake_app():
    return FakeApplication()


def dump_credentials(credentials):
    return {
        "credentials": credentials.class_name(),
        "credentials_data": credentials.dump(),
    }
