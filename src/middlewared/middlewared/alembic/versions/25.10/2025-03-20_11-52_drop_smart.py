"""Remove SMART support

Revision ID: f15312414057
Revises: 9a5b103ec2e4
Create Date: 2025-03-20 11:52:20.261454+00:00

"""
from collections import namedtuple
import json
import re
import shlex

from alembic import op
import sqlalchemy as sa
from sqlalchemy import text


# revision identifiers, used by Alembic.
revision = 'f15312414057'
down_revision = '9a5b103ec2e4'
branch_labels = None
depends_on = None


RE_RANGE_WITH_DIVISOR = re.compile(r"((?P<min>[0-9]+)-(?P<max>[0-9]+)|\*)/(?P<divisor>[0-9]+)")
RE_RANGE = re.compile(r"((?P<min>[0-9]+)-(?P<max>[0-9]+)|\*)")

SchedulePiece = namedtuple("SchedulePiece", ["key", "min", "max", "enum", "map"])
SMARTD_SCHEDULE_PIECES = [
    SchedulePiece("month", 1, 12, dict(zip([
        "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"
    ], range(1, 13))), None),
    SchedulePiece("dom", 1, 31, None, None),
    SchedulePiece("dow", 1, 7, dict(zip([
        "mon", "tue", "wed", "thu", "fri", "sat", "sun"
    ], range(1, 8))), {0: 7}),
    SchedulePiece("hour", 0, 23, None, None),
]


def smartd_schedule_piece(value, min_, max_, enum=None, map_=None):
    enum = enum or {}
    map_ = map_ or {}

    if value == "*":
        return "*"
    elif m := RE_RANGE_WITH_DIVISOR.match(value):
        d = int(m.group("divisor"))
        if m.group("min") is None:
            if d == 1:
                return "*"
            else:
                return f"*/{d}"
        else:
            min_ = int(m.group("min"))
            max_ = int(m.group("max"))
            return f"{min_}-{max_}/{d}"
    elif m := RE_RANGE.match(value):
        start = int(m.group("min"))
        end = int(m.group("max"))
        return f"{start}-{end}"
    else:
        values = list(filter(lambda v: v is not None,
                             map(lambda s: enum.get(s.lower(), int(s) if s.isdigit() else None),
                                 value.split(","))))
        values = [map_.get(v, v) for v in values]
        if values == list(range(min_, max_ + 1)):
            return "*"
        else:
            return ",".join(map(str, values))


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    conn = op.get_bind()
    for row in conn.execute(text(f"SELECT * FROM tasks_smarttest")).mappings().all():
        try:
            if row["smarttest_all_disks"]:
                disks = ["*"]
            else:
                disks = [
                    disk["disk_id"]
                    for disk in conn.execute(
                        text("SELECT * FROM tasks_smarttest_smarttest_disks WHERE smarttest_id = :smarttest_id"),
                        {"smarttest_id": row["id"]}
                    ).mappings().all()
                ]

            if not disks:
                continue

            hour = smartd_schedule_piece(row["smarttest_hour"], 0, 23)
            daymonth = smartd_schedule_piece(row["smarttest_daymonth"], 1, 31)
            month = smartd_schedule_piece(row["smarttest_month"], 1, 12, dict(zip([
                "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"
            ], range(1, 13))))
            dayweek = smartd_schedule_piece(row["smarttest_dayweek"], 1, 7, dict(zip([
                "mon", "tue", "wed", "thu", "fri", "sat", "sun"
            ], range(1, 8))), {0: 7})

            types_ = {
                'L': 'LONG',
                'S': 'SHORT',
                'C': 'CONVEYANCE',
                'O': 'OFFLINE',
            }
            command = f"midclt call disk.smart_test {types_[row['smarttest_type']]} {shlex.quote(json.dumps(disks))}"

            description = "S.M.A.R.T. Test"
            if row["smarttest_desc"]:
                description += ": " + row["smarttest_desc"]

            conn.execute(
                text("INSERT INTO tasks_cronjob (cron_minute, cron_hour, cron_daymonth, cron_month, cron_dayweek, "
                     "cron_user, cron_command, cron_description, cron_enabled, cron_stdout, cron_stderr) VALUES "
                     "('00', :hour, :daymonth, :month, :dayweek, 'root', :command, :description, 1, 1, 1)"),
                {
                    "hour": hour, "daymonth": daymonth, "month": month, "dayweek": dayweek, 
                    "command": command, "description": description
                }
            )
        except Exception:
            raise

    # There is no need to drop tasks_smarttest_smarttest_disks indices explicitly as they will be
    # dropped automatically when the table is dropped.
    # https://sqlite.org/lang_droptable.html
    op.drop_table('tasks_smarttest_smarttest_disks')
    op.drop_table('services_smart')
    op.drop_table('tasks_smarttest')
    with op.batch_alter_table('storage_disk', schema=None) as batch_op:
        batch_op.drop_column('disk_critical')
        batch_op.drop_column('disk_togglesmart')
        batch_op.drop_column('disk_informational')
        batch_op.drop_column('disk_difference')

    op.execute(text("DELETE FROM services_services WHERE srv_service = 'smartd'"))
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('storage_disk', schema=None) as batch_op:
        batch_op.add_column(sa.Column('disk_difference', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('disk_informational', sa.INTEGER(), nullable=True))
        batch_op.add_column(sa.Column('disk_togglesmart', sa.BOOLEAN(), nullable=False))
        batch_op.add_column(sa.Column('disk_critical', sa.INTEGER(), nullable=True))

    op.create_table('tasks_smarttest',
    sa.Column('id', sa.INTEGER(), nullable=False),
    sa.Column('smarttest_type', sa.VARCHAR(length=2), nullable=False),
    sa.Column('smarttest_desc', sa.VARCHAR(length=120), nullable=False),
    sa.Column('smarttest_hour', sa.VARCHAR(length=100), nullable=False),
    sa.Column('smarttest_daymonth', sa.VARCHAR(length=100), nullable=False),
    sa.Column('smarttest_month', sa.VARCHAR(length=100), nullable=False),
    sa.Column('smarttest_dayweek', sa.VARCHAR(length=100), nullable=False),
    sa.Column('smarttest_all_disks', sa.BOOLEAN(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('services_smart',
    sa.Column('id', sa.INTEGER(), nullable=False),
    sa.Column('smart_interval', sa.INTEGER(), nullable=False),
    sa.Column('smart_powermode', sa.VARCHAR(length=60), nullable=False),
    sa.Column('smart_difference', sa.INTEGER(), nullable=False),
    sa.Column('smart_informational', sa.INTEGER(), nullable=False),
    sa.Column('smart_critical', sa.INTEGER(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('tasks_smarttest_smarttest_disks',
    sa.Column('id', sa.INTEGER(), nullable=False),
    sa.Column('smarttest_id', sa.INTEGER(), nullable=False),
    sa.Column('disk_id', sa.VARCHAR(length=100), nullable=False),
    sa.ForeignKeyConstraint(['disk_id'], ['storage_disk.disk_identifier'], name='fk_tasks_smarttest_smarttest_disks_disk_id_storage_disk', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['smarttest_id'], ['tasks_smarttest.id'], name='fk_tasks_smarttest_smarttest_disks_smarttest_id_tasks_smarttest', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    with op.batch_alter_table('tasks_smarttest_smarttest_disks', schema=None) as batch_op:
        batch_op.create_index('tasks_smarttest_smarttest_disks_smarttest_id__disk_id', ['smarttest_id', 'disk_id'], unique=False)

    # ### end Alembic commands ###
